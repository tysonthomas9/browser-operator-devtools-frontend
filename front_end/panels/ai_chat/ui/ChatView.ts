// Copyright 2025 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import * as Marked from '../../../third_party/marked/marked.js';
import * as ComponentHelpers from '../../../ui/components/helpers/helpers.js';
import * as MarkdownView from '../../../ui/components/markdown_view/markdown_view.js';
import * as Lit from '../../../ui/lit/lit.js';
import * as BaseOrchestratorAgent from '../core/BaseOrchestratorAgent.js';

import chatViewStyles from './chatView.css.js';

const {html, Decorators} = Lit;
const {customElement} = Decorators;

// A simplified version of the MarkdownRenderer with code block support
class MarkdownRenderer extends MarkdownView.MarkdownView.MarkdownInsightRenderer {
  override templateForToken(token: Marked.Marked.MarkedToken): Lit.TemplateResult|null {
    if (token.type === 'code') {
      const lines = (token.text).split('\n');
      if (lines[0]?.trim() === 'css') {
        token.lang = 'css';
        token.text = lines.slice(1).join('\n');
      }
    }

    return super.templateForToken(token);
  }
}

// Function to render text as markdown
function renderMarkdown(text: string, markdownRenderer: MarkdownRenderer): Lit.TemplateResult {
  let tokens = [];
  try {
    tokens = Marked.Marked.lexer(text);
    for (const token of tokens) {
      // Try to render all the tokens to make sure that
      // they all have a template defined for them. If there
      // isn't any template defined for a token, we'll fallback
      // to rendering the text as plain text instead of markdown.
      markdownRenderer.renderToken(token);
    }
  } catch {
    // The tokens were not parsed correctly or
    // one of the tokens are not supported, so we
    // continue to render this as text.
    return html`${text}`;
  }

  return html`<devtools-markdown-view
    .data=${{tokens, renderer: markdownRenderer} as MarkdownView.MarkdownView.MarkdownViewData}>
  </devtools-markdown-view>`;
}

// Types for the ChatView component

// Define possible entities for chat messages
export enum ChatMessageEntity {
  USER = 'user',
  MODEL = 'model',
  TOOL_RESULT = 'tool_result',
}

// Base structure for all chat messages
export interface BaseChatMessage {
  entity: ChatMessageEntity;
  error?: string;
}

// Represents a message sent by the user
export interface UserChatMessage extends BaseChatMessage {
  entity: ChatMessageEntity.USER;
  text: string;
  imageInput?: ImageInputData;
}

// Represents a message generated by the AI model
// This now directly contains the agent's action details
export interface ModelChatMessage extends BaseChatMessage {
  entity: ChatMessageEntity.MODEL;
  // Type of action the model decided on
  action: 'tool' | 'final';
  // Tool details (only relevant if action is 'tool')
  toolName?: string;
  toolArgs?: Record<string, unknown>;
  // Final answer (only relevant if action is 'final')
  answer?: string;
  // Indicates if this message concludes the agent's turn (set if action is 'final')
  isFinalAnswer: boolean;
  // Reasoning summary from the model
  reasoning?: string[] | null;
  // REMOVED steps?: Step[];
}

// Represents the result of a tool execution
export interface ToolResultMessage extends BaseChatMessage {
    entity: ChatMessageEntity.TOOL_RESULT;
    toolName: string;
    resultText: string;
    isError: boolean;
    // Add optional structured data field
    resultData?: any;
}

// Union type representing any possible chat message
export type ChatMessage =
    UserChatMessage|ModelChatMessage|ToolResultMessage;

// Defines the structure of an image input
export interface ImageInputData {
  url: string;
  bytesBase64: string;
}

// Structure for enhanced responses (e.g., markdown, code blocks)
// This might be less relevant now if answers are plain text
export interface EnhancedResponse {
  type: 'markdown' | 'code';
  content: string;
}

// REMOVED Step interface entirely

export enum State {
  IDLE = 'idle',
  LOADING = 'loading',
  ERROR = 'error',
}

export interface Props {
  messages: ChatMessage[];
  onSendMessage: (text: string, imageInput?: ImageInputData) => void;
  onPromptSelected: (promptType: string) => void;
  state: State;
  isTextInputEmpty: boolean;
  imageInput?: ImageInputData;
  onImageInputClear?: () => void;
  onImageInputChange?: (imageInput: ImageInputData) => void;
  // Add model selection properties
  modelOptions?: Array<{value: string, label: string}>;
  selectedModel?: string;
  onModelChanged?: (model: string) => void;
  onModelSelectorFocus?: () => void;
  selectedAgentType?: string | null;
  isModelSelectorDisabled?: boolean;
  // Add API key related properties
  isInputDisabled?: boolean;
  inputPlaceholder?: string;
}

@customElement('devtools-chat-view')
export class ChatView extends HTMLElement {
  static readonly litTagName = Lit.StaticHtml.literal`devtools-chat-view`;
  readonly #shadow = this.attachShadow({mode: 'open'});
  readonly #boundRender = this.#render.bind(this);

  #messages: ChatMessage[] = [];
  #state: State = State.IDLE;
  #isTextInputEmpty = true;
  #imageInput?: ImageInputData;
  #onSendMessage?: (text: string, imageInput?: ImageInputData) => void;
  #onImageInputClear?: () => void;
  #onPromptSelected?: (promptType: string) => void;
  #textInputElement?: HTMLTextAreaElement;
  #markdownRenderer = new MarkdownRenderer();
  #isFirstMessageView = true; // Track if we're in the centered first-message view
  #selectedPromptType?: string | null; // Track the currently selected prompt type
  #handlePromptButtonClickBound: (event: Event) => void = () => {}; // Initialize with empty function, will be properly set in connectedCallback
  // Add model selection properties
  #modelOptions?: Array<{value: string, label: string}>;
  #selectedModel?: string;
  #onModelChanged?: (model: string) => void;
  #onModelSelectorFocus?: () => void;
  #selectedAgentType?: string | null;
  #isModelSelectorDisabled = false;

  // Add scroll-related properties
  #messagesContainerElement?: HTMLElement;
  #messagesContainerResizeObserver = new ResizeObserver(() => this.#handleMessagesContainerResize());
  #pinScrollToBottom = true;

  // Add properties for input disabled state and placeholder
  #isInputDisabled = false;
  #inputPlaceholder = '';

  connectedCallback(): void {
    const sheet = new CSSStyleSheet();
    sheet.replaceSync(chatViewStyles);
    this.#shadow.adoptedStyleSheets = [sheet];

    // Initialize the prompt button click handler
    this.#updatePromptButtonClickHandler();

    // Observe the messages container for size changes if it exists
    if (this.#messagesContainerElement) {
      this.#messagesContainerResizeObserver.observe(this.#messagesContainerElement);
    }

    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);
  }

  disconnectedCallback(): void {
    // Cleanup resize observer
    this.#messagesContainerResizeObserver.disconnect();
  }

  // Add method to scroll to bottom
  #scrollToBottom(): void {
    if (!this.#messagesContainerElement) {
      return;
    }

    this.#messagesContainerElement.scrollTop = this.#messagesContainerElement.scrollHeight;
  }

  // Add method to handle resizing of messages container
  #handleMessagesContainerResize(): void {
    if (!this.#pinScrollToBottom) {
      return;
    }

    if (!this.#messagesContainerElement) {
      return;
    }

    this.#scrollToBottom();
  }

  // Add method to handle scroll events
  #handleScroll = (event: Event): void => {
    if (!event.target || !(event.target instanceof HTMLElement)) {
      return;
    }

    const container = event.target as HTMLElement;
    const SCROLL_ROUNDING_OFFSET = 1; // Add small offset to handle rounding errors

    // Consider "scrolled to bottom" if within 1px of the bottom
    this.#pinScrollToBottom =
      container.scrollTop + container.clientHeight + SCROLL_ROUNDING_OFFSET >= container.scrollHeight;
  };

  // Add method to handle message container reference
  #handleMessagesContainerRef = (el: Element | undefined): void => {
    // Remove old observer if it exists
    if (this.#messagesContainerElement) {
      this.#messagesContainerResizeObserver.unobserve(this.#messagesContainerElement);
    }

    this.#messagesContainerElement = el as HTMLElement | undefined;

    if (el) {
      this.#messagesContainerResizeObserver.observe(el);
      // Initially scroll to bottom when container is first created
      this.#scrollToBottom();
    } else {
      this.#pinScrollToBottom = true;
    }
  };

  // Update the prompt button click handler when props/state changes
  #updatePromptButtonClickHandler(): void {
    this.#handlePromptButtonClickBound = BaseOrchestratorAgent.createAgentTypeSelectionHandler(
      this,
      this.#textInputElement,
      this.#onPromptSelected,
      (type: string) => {
        this.#selectedPromptType = type;
        void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);
      }
    );
  }

  // Public getter to expose the centered view state
  get isCenteredView(): boolean {
    return this.#isFirstMessageView;
  }

  set data(data: Props) {
    const previousMessageCount = this.#messages.length;
    const willHaveMoreMessages = data.messages.length > previousMessageCount;

    this.#messages = data.messages;
    this.#state = data.state;
    this.#isTextInputEmpty = data.isTextInputEmpty;
    this.#imageInput = data.imageInput;
    this.#onSendMessage = data.onSendMessage;
    this.#onImageInputClear = data.onImageInputClear;
    this.#onPromptSelected = data.onPromptSelected;
    // Add model selection properties
    this.#modelOptions = data.modelOptions;
    this.#selectedModel = data.selectedModel;
    this.#onModelChanged = data.onModelChanged;
    this.#onModelSelectorFocus = data.onModelSelectorFocus;
    this.#selectedAgentType = data.selectedAgentType;
    this.#isModelSelectorDisabled = data.isModelSelectorDisabled || false;

    // Store input disabled state and placeholder
    this.#isInputDisabled = data.isInputDisabled || false;
    this.#inputPlaceholder = data.inputPlaceholder || 'Ask AI Assistant...';

    // Update the selectedPromptType from the passed selectedAgentType if it exists
    if (data.selectedAgentType !== undefined) {
      this.#selectedPromptType = data.selectedAgentType;
    }

    // Check if we should exit the first message view state
    // We're no longer in first message view if there are user messages
    const hasUserMessages = data.messages.some(msg => msg.entity === ChatMessageEntity.USER);
    this.#isFirstMessageView = !hasUserMessages;

    // Update the prompt button handler with new props
    this.#updatePromptButtonClickHandler();

    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);

    // After rendering, scroll to bottom if we have new messages and auto-scroll is enabled
    if (this.#pinScrollToBottom && willHaveMoreMessages) {
      // Give the DOM time to update before scrolling
      setTimeout(() => this.#scrollToBottom(), 0);
    }
  }

  #handleSendMessage(): void {
    if (!this.#textInputElement || !this.#onSendMessage) {
      return;
    }

    const text = this.#textInputElement.value.trim();
    if (!text) {
      return;
    }

    // Exit the first message view mode when sending a message
    this.#isFirstMessageView = false;

    // Always scroll to bottom after sending message
    this.#pinScrollToBottom = true;

    this.#onSendMessage(text, this.#imageInput);
    this.#textInputElement.value = '';
    this.#textInputElement.style.height = 'auto';
    this.#isTextInputEmpty = true;
    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);
  }

  #handleKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault();
      this.#handleSendMessage();
    }
  }

  #handleTextInput(event: Event): void {
    const textarea = event.target as HTMLTextAreaElement;
    textarea.style.height = 'auto'; // Reset height to shrink if needed
    textarea.style.height = `${textarea.scrollHeight}px`;
    this.#isTextInputEmpty = textarea.value.trim().length === 0;
    void ComponentHelpers.ScheduledRender.scheduleRender(this, this.#boundRender);
  }

  // Render messages based on the combined structure
  #renderMessage(message: ChatMessage | (ModelChatMessage & { resultText?: string, isError?: boolean, resultError?: string, combined?: boolean }) | (ToolResultMessage & { orphaned?: boolean }) ): Lit.TemplateResult {
    try {
      switch (message.entity) {
        case ChatMessageEntity.USER:
          // Render User Message
          return html`
            <div class="message user-message" >
              <div class="message-content">
                <div class="message-text">${renderMarkdown(message.text || '', this.#markdownRenderer)}</div>
                ${message.error ? html`<div class="message-error">${message.error}</div>` : Lit.nothing}
              </div>
            </div>
          `;

        case ChatMessageEntity.MODEL:
          {
            // Cast to the potentially combined type
            const modelMessage = message as (ModelChatMessage & { resultText?: string, isError?: boolean, resultError?: string, combined?: boolean });

            // Check if it's a combined message (tool call + result) or just a running tool call / final answer
            const isCombined = modelMessage.combined === true;
            const isRunningTool = modelMessage.action === 'tool' && !isCombined;
            const isFinal = modelMessage.action === 'final';

            // --- Render Final Answer ---
            if (isFinal) {
              return html`
                <div class="message model-message final">
                  <div class="message-content">
                    ${modelMessage.answer ?
                      html`
                        <div class="message-text">${renderMarkdown(modelMessage.answer, this.#markdownRenderer)}</div>
                      ` :
                      Lit.nothing
                    }
                    ${modelMessage.reasoning?.length ? html`
                      <div class="reasoning-block">
                        <details class="reasoning-details">
                          <summary class="reasoning-summary">
                            <span class="reasoning-icon">💡</span>
                            <span>Model Reasoning</span>
                          </summary>
                          <div class="reasoning-content">
                            ${modelMessage.reasoning.map(item => html`
                              <div class="reasoning-item">${renderMarkdown(item, this.#markdownRenderer)}</div>
                            `)}
                          </div>
                        </details>
                      </div>
                    ` : Lit.nothing}
                    ${modelMessage.error ? html`<div class="message-error">${modelMessage.error}</div>` : Lit.nothing}
                  </div>
                </div>
              `;
            }

            // --- Render Combined Tool Call + Result OR Running Tool Call (with new styling) ---
            const toolReasoning = modelMessage.toolArgs?.reasoning as string | undefined;
            const resultText = modelMessage.resultText; // Available if combined
            const isResultError = modelMessage.isError ?? false; // Available if combined, default false
            const toolArgs = modelMessage.toolArgs || {};
            const filteredArgs = Object.fromEntries(Object.entries(toolArgs).filter(([key]) => key !== 'reasoning'));

            // --- Styling and Icons ---
            const blockStyles = (bgColor: string) => Lit.Directives.styleMap({
              padding: '10px',
              borderRadius: '8px',
              marginBottom: '5px', // Reduced margin between blocks if they are separate
              border: '1px solid var(--sys-color-outline)',
              backgroundColor: bgColor,
            });

            const headerStyles = Lit.Directives.styleMap({
              display: 'flex',
              alignItems: 'center',
              gap: '8px',
              marginBottom: '8px',
              fontWeight: '500',
            });

            const contentStyles = Lit.Directives.styleMap({
              marginLeft: '24px', // Indent content under the header icon
              paddingTop: '5px',
            });

            // Icons
            const spinnerIcon = html`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="animation: spin 1s linear infinite;"><path d="M8 1.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13zM8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0z" fill="currentColor"/><path d="M8 0a8 8 0 0 1 8 8h-1.5A6.5 6.5 0 0 0 8 1.5V0z" fill="currentColor"/></svg>`;
            const checkIcon = html`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.7071 4.29289C14.0976 4.68342 14.0976 5.31658 13.7071 5.70711L7.70711 11.7071C7.31658 12.0976 6.68342 12.0976 6.29289 11.7071L2.29289 7.70711C1.90237 7.31658 1.90237 6.68342 2.29289 6.29289C2.68342 5.90237 3.31658 5.90237 3.70711 6.29289L7 9.58579L12.2929 4.29289C12.6834 3.90237 13.3166 3.90237 13.7071 4.29289Z" fill="currentColor"/></svg>`;
            const errorIcon = html`<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8 1.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13zM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm8.78-2.53a.75.75 0 0 0-1.56 0v5.06a.75.75 0 0 0 1.56 0V5.47zm-1.5 7.06a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5z" fill="currentColor"/></svg>`;
            // --- End Styling and Icons ---

            return html`
              <!-- Reasoning (if any) displayed above the block -->
              ${toolReasoning ? html`
                <div class="message-text reasoning-text" style="margin-bottom: 8px;">
                  ${renderMarkdown(toolReasoning, this.#markdownRenderer)}
                </div>
              ` : Lit.nothing}

              <!-- Tool Interaction Block (using details/summary) -->
              <details class="message model-message tool-interaction-details" ?open=${isRunningTool} >
                <!-- Clickable Summary (Styled like Refine Box) -->
                <summary class="tool-call-summary">
                  <!-- Icon -->
                  <span class=${isRunningTool ? 'spinner-icon' : ''}>
                    ${isRunningTool ? spinnerIcon : (isResultError ? errorIcon : checkIcon)}
                  </span>
                  
                  <!-- Text Block (Tool Name + Status) -->
                  <div class="tool-name-container"> 
                    <span class="tool-name">Tool: ${modelMessage.toolName}</span>
                    <span class="tool-status-text">
                      ${isRunningTool ? 'running...' : (isResultError ? 'Error' : 'Completed')}
                    </span>
                  </div>
                </summary>

                <!-- Content inside details (Args + Result Block) -->
                <div class="tool-details-content"> 
                  <!-- Args Section -->
                  <div class="tool-args-container">
                    <div class="tool-args-section">
                      <span class="tool-args-label">Args:</span>
                     ${Object.keys(filteredArgs).length > 0 ? html`
                       <div class="tool-args-value">
                           ${Object.entries(filteredArgs)
                               .map(([key, value]) => html`<div><span class="tool-arg-key">${key}</span>${JSON.stringify(value)}</div>`)
                               .reduce((prev, curr) => html`${prev}${curr}`, html``)
                           }
                       </div>
                     ` : html`<div class="tool-no-args">No arguments</div>`}
                    </div>
                  </div>
                  <!-- Reasoning Section (if available) -->
                  ${modelMessage.reasoning?.length ? html`
                    <div class="reasoning-block">
                      <details class="reasoning-details">
                        <summary class="reasoning-summary">
                          <span class="reasoning-icon">💡</span>
                          <span>Model Reasoning</span>
                        </summary>
                        <div class="reasoning-content">
                          ${modelMessage.reasoning.map(item => html`
                            <div class="reasoning-item">${renderMarkdown(item, this.#markdownRenderer)}</div>
                          `)}
                        </div>
                      </details>
                    </div>
                  ` : Lit.nothing}
                  ${modelMessage.error ? html`<div class="message-error tool-error-message">Model Error: ${modelMessage.error}</div>` : Lit.nothing}

                  <!-- Result Block - Only shown when combined -->
                  ${isCombined ? html`
                    <div class="tool-result-block ${isResultError ? 'error' : 'success'}" >
                      <div class="tool-result-header">
                        ${isResultError ? errorIcon : checkIcon}
                        <span>Result from: ${modelMessage.toolName}</span>
                      </div>
                      <div class="tool-result-content">
                        ${this.#formatJsonWithSyntaxHighlighting(resultText || 'No result content')}
                      </div>
                      ${modelMessage.resultError ? html`<div class="message-error tool-error-message">Tool Error: ${modelMessage.resultError}</div>` : Lit.nothing}
                    </div>
                  ` : Lit.nothing}
                </div>
              </details>
            `;
          }

        case ChatMessageEntity.TOOL_RESULT:
          // Should only render if orphaned
          {
             const toolResultMessage = message as (ToolResultMessage & { orphaned?: boolean });
             if (toolResultMessage.orphaned) {
                 console.warn('Rendering orphaned ToolResultMessage:', toolResultMessage);
                 return html`
                   <div class="message tool-result-message orphaned ${toolResultMessage.isError ? 'error' : ''}" >
                     <div class="message-content">
                       <div class="tool-status completed">
                           <div class="tool-name-display">
                             Orphaned Result from: ${toolResultMessage.toolName} ${toolResultMessage.isError ? '(Error)' : ''}
                           </div>
                           <pre class="tool-result-raw">${toolResultMessage.resultText}</pre>
                           ${toolResultMessage.error ? html`<div class="message-error">${toolResultMessage.error}</div>` : Lit.nothing}
                       </div>
                     </div>
                   </div>
                 `;
             }
             // If not orphaned, it should have been combined, so render nothing.
             return html``;
          }
        default:
          // Should not happen, but render a fallback
          console.warn('Unhandled message entity type in renderMessage:', (message as any).entity);
          return html`<div class="message unknown">Unknown message type</div>`;
      }
    } catch (error) {
      console.error('Error rendering message:', error);
      return html`
        <div class="message model-message error" >
          <div class="message-content">
            <div class="message-error">Failed to render message: ${error instanceof Error ? error.message : String(error)}</div>
          </div>
        </div>
      `;
    }
  }

  #render(): void {
    // clang-format off
    // Check if the last message is a MODEL message indicating a tool is running
    const lastMessage = this.#messages[this.#messages.length - 1];
    const isModelRunningTool = lastMessage?.entity === ChatMessageEntity.MODEL && !lastMessage.isFinalAnswer && lastMessage.toolName;

    // Combine the tool calling and tool result messages into a single logical unit for rendering
    const combinedMessages = this.#messages.reduce((acc, message, index, allMessages) => {
      // Keep User messages and Final Model answers
      if (message.entity === ChatMessageEntity.USER ||
          (message.entity === ChatMessageEntity.MODEL && message.action === 'final')) {
        acc.push(message);
        return acc;
      }

      // Handle Model Tool Call message
      if (message.entity === ChatMessageEntity.MODEL && message.action === 'tool') {
        const modelMessage = message as ModelChatMessage;
        const nextMessage = allMessages[index + 1];

        // Check if the next message is the corresponding result
        if (nextMessage && nextMessage.entity === ChatMessageEntity.TOOL_RESULT && nextMessage.toolName === modelMessage.toolName) {
          // Create a combined representation: add result to model message
          // IMPORTANT: Create a new object, don't mutate the original state
          const combinedRepresentation = {
            ...modelMessage, // Copy model call details
            // Add result details directly to this combined object
            resultText: (nextMessage as ToolResultMessage).resultText,
            isError: (nextMessage as ToolResultMessage).isError,
            resultError: (nextMessage as ToolResultMessage).error, // Keep original model error separate if needed
            combined: true, // Add a flag to identify this combined message
          };
          acc.push(combinedRepresentation);
        } else {
          // Tool call is still running (no result yet) or result is missing
          // Add the model message as is (it will render the "running" state)
          acc.push(modelMessage);
        }
        return acc;
      }

      // Handle Tool Result message - skip if it was combined previously
      if (message.entity === ChatMessageEntity.TOOL_RESULT) {
        const prevMessage = allMessages[index - 1];
        // Check if the previous message was the corresponding model call
        if (!(prevMessage && prevMessage.entity === ChatMessageEntity.MODEL && prevMessage.action === 'tool' && prevMessage.toolName === message.toolName)) {
           // Orphaned tool result - add it directly (maybe mark it?)
           console.warn('Orphaned tool result found:', message);
           acc.push({...message, orphaned: true }); // Add marker if needed for rendering
        }
        // Otherwise, it was handled by the MODEL case above, so we skip this result message
        return acc;
      }

      // Fallback for any unexpected message types (shouldn't happen)
      acc.push(message);
      return acc;

    // Define the type for the accumulator array more accurately
    // Allow ToolResultMessage to potentially have an 'orphaned' flag
    }, [] as Array<ChatMessage | (ModelChatMessage & { resultText?: string, isError?: boolean, resultError?: string, combined?: boolean }) | (ToolResultMessage & { orphaned?: boolean }) >);

    // General loading state (before any model response or after tool result)
    const showGeneralLoading = this.#state === State.LOADING && !isModelRunningTool;

    // Find the last model message with an answer to use for the copy action
    let lastModelAnswer: string | null = null;
    // Loop backwards through messages to find the most recent model answer
    for (let i = this.#messages.length - 1; i >= 0; i--) {
      const msg = this.#messages[i];
      if (msg.entity === ChatMessageEntity.MODEL) {
        const modelMsg = msg as ModelChatMessage;
        if (modelMsg.action === 'final' && modelMsg.answer) {
          lastModelAnswer = modelMsg.answer;
          break;
        }
      }
    }

    // Determine whether to show actions row (not in first message view, not loading, has a model answer)
    const showActionsRow = !this.#isFirstMessageView &&
                          this.#state !== State.LOADING &&
                          lastModelAnswer !== null;

    // Determine which view to render based on the first message state
    if (this.#isFirstMessageView) {
      // Render centered first message view
      const welcomeMessage = this.#messages.length > 0 ? this.#messages[0] : null;

      Lit.render(html`
        <div class="chat-view-container centered-view">
          <div class="centered-content">
            ${welcomeMessage ? this.#renderMessage(welcomeMessage) : Lit.nothing}
            
            <div class="input-container centered" >
              ${this.#imageInput ? html`
                <div class="image-preview">
                  <img src=${this.#imageInput.url} alt="Image input" /> 
                  <button class="image-remove-button" @click=${() => this.#onImageInputClear && this.#onImageInputClear()}> 
                    <span class="icon">×</span>
                  </button>
                </div>
              ` : Lit.nothing}
              <div class="input-row">
                <textarea
                  class="text-input"
                  placeholder=${this.#inputPlaceholder}
                  rows="1"
                  @keydown=${this.#handleKeyDown.bind(this)}
                  @input=${this.#handleTextInput.bind(this)}
                  ?disabled=${this.#isInputDisabled}
                  ${Lit.Directives.ref((el: Element | undefined) => {
                    this.#textInputElement = el as HTMLTextAreaElement;
                  })}
                ></textarea>
              </div>
              <!-- Prompt Buttons Row -->
              <div class="prompt-buttons-row">
                ${BaseOrchestratorAgent.renderAgentTypeButtons(this.#selectedPromptType, this.#handlePromptButtonClickBound, true)}

                <div class="actions-container">
                  ${this.#renderModelSelector()}
                  <button
                    class="send-button ${this.#isTextInputEmpty || this.#isInputDisabled ? 'disabled' : ''}"
                    ?disabled=${this.#isTextInputEmpty || this.#isInputDisabled}
                    @click=${this.#handleSendMessage.bind(this)}
                    title="Send message"
                    aria-label="Send message"
                  >
                  <svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                    <path
                      fill="none" 
                      stroke="currentColor" 
                      stroke-width="2" 
                      stroke-linecap="round" 
                      stroke-linejoin="round" 
                      d="M29.4,15.1
                        l-8.9-3.5
                        l-3.5-8.9
                        C16.8,2.3,16.4,2,16,2
                        s-0.8,0.3-0.9,0.6
                        l-3.5,8.9
                        l-8.9,3.5
                        C2.3,15.2,2,15.6,2,16
                        s0.3,0.8,0.6,0.9
                        l8.9,3.5
                        l3.5,8.9
                        c0.2,0.4,0.5,0.6,0.9,0.6
                        s0.8-0.3,0.9-0.6
                        l3.5-8.9
                        l8.9-3.5
                        c0.4-0.2,0.6-0.5,0.6-0.9
                        S29.7,15.2,29.4,15.1
                      z" />
                  </svg>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      `, this.#shadow, {host: this});
    } else {
      // Render normal expanded view for conversation
      Lit.render(html`
        <div class="chat-view-container expanded-view">
          <div class="messages-container" 
            @scroll=${this.#handleScroll} 
            ${Lit.Directives.ref(this.#handleMessagesContainerRef)}>
            ${combinedMessages?.map(message => this.#renderMessage(message)) || Lit.nothing}

            ${showGeneralLoading ? html`
              <div class="message model-message loading" >
                <div class="message-content">
                  <div class="message-loading">
                    <svg class="loading-spinner" width="16" height="16" viewBox="0 0 16 16">
                      <circle cx="8" cy="8" r="6" stroke="currentColor" stroke-width="2" fill="none" stroke-dasharray="30 12" stroke-linecap="round">
                        <animateTransform 
                          attributeName="transform" 
                          attributeType="XML" 
                          type="rotate" 
                          from="0 8 8" 
                          to="360 8 8" 
                          dur="1s" 
                          repeatCount="indefinite" />
                      </circle>
                    </svg>
                  </div>
                </div>
              </div>
            ` : Lit.nothing}
            
            <!-- Global actions row - only shown when chat is complete -->
            ${showActionsRow ? html`
              <div class="global-actions-container">
                <div class="message-actions-row">
                  <button class="message-action-button" @click=${() => this.#copyToClipboard(lastModelAnswer || '')} title="Copy to clipboard">
                    <svg class="action-icon" viewBox="0 0 24 24" width="16" height="16">
                      <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" fill="currentColor"></path>
                    </svg>
                    <span class="action-tooltip">Copy</span>
                  </button>
                  <button class="message-action-button thumbs-up" title="Helpful">
                    <svg class="action-icon" viewBox="0 0 24 24" width="16" height="16">
                      <path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z" fill="currentColor"></path>
                    </svg>
                    <span class="action-tooltip">Helpful</span>
                  </button>
                  <button class="message-action-button thumbs-down" title="Not helpful">
                    <svg class="action-icon" viewBox="0 0 24 24" width="16" height="16">
                      <path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z" fill="currentColor"></path>
                    </svg>
                    <span class="action-tooltip">Not helpful</span>
                  </button>
                  <button class="message-action-button retry" title="Regenerate response">
                    <svg class="action-icon" viewBox="0 0 24 24" width="16" height="16">
                      <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z" fill="currentColor"></path>
                    </svg>
                    <span class="action-tooltip">Retry</span>
                  </button>
                </div>
              </div>
            ` : Lit.nothing}
          </div>
          <div class="input-container" >
            ${this.#imageInput ? html`
              <div class="image-preview">
                <img src=${this.#imageInput.url} alt="Image input" /> 
                <button class="image-remove-button" @click=${() => this.#onImageInputClear && this.#onImageInputClear()}> 
                  <span class="icon">×</span>
                </button>
              </div>
            ` : Lit.nothing}
            <div class="input-row">
              <textarea
                class="text-input"
                placeholder=${this.#inputPlaceholder}
                rows="1"
                @keydown=${this.#handleKeyDown.bind(this)}
                @input=${this.#handleTextInput.bind(this)}
                ?disabled=${this.#isInputDisabled}
                ${Lit.Directives.ref((el: Element | undefined) => {
                  this.#textInputElement = el as HTMLTextAreaElement;
                })}
              ></textarea>
              <button
                class="send-button ${this.#isTextInputEmpty || this.#isInputDisabled ? 'disabled' : ''}"
                ?disabled=${this.#isTextInputEmpty || this.#isInputDisabled}
                @click=${this.#handleSendMessage.bind(this)}
                title="Send message"
                aria-label="Send message"
              >
                <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">
                  <line x1="22" y1="2" x2="11" y2="13"></line>
                  <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                </svg>
              </button>
            </div>
              <!-- Prompt Buttons Row -->
              <div class="prompt-buttons-row">
                ${BaseOrchestratorAgent.renderAgentTypeButtons(this.#selectedPromptType, this.#handlePromptButtonClickBound)}
                <div class="actions-container">
                  ${this.#renderModelSelector()}
                </div>
              </div>
            </div>
          </div>
        </div>
      `, this.#shadow, {host: this});
    }
    // clang-format on
  }

  // Helper method to format JSON with syntax highlighting
  #formatJsonWithSyntaxHighlighting(jsonString: string): Lit.TemplateResult {
    try {
      // Only process if it looks like JSON
      if (jsonString.trim().startsWith('{') || jsonString.trim().startsWith('[')) {
        const parsed = JSON.parse(jsonString);
        const formatted = JSON.stringify(parsed, null, 2);

        // Replace keys, strings, and booleans with highlighted spans
        const highlighted = formatted
          .replace(/"([^"]+)":/g, '<span class="tool-result-json-key">"$1"</span>:')
          .replace(/"([^"]+)"/g, '<span class="tool-result-json-string">"$1"</span>')
          .replace(/\b(true|false)\b/g, '<span class="tool-result-json-boolean">$1</span>');

        return html`<div .innerHTML=${highlighted}></div>`;
      }

      // If not JSON or parsing fails, return as is
      return html`${jsonString}`;
    } catch (e) {
      // If JSON parsing fails, return original text
      return html`${jsonString}`;
    }
  }

  // Add helper to render model selector
  #renderModelSelector() {
    if (!this.#modelOptions || !this.#modelOptions.length || !this.#selectedModel || !this.#onModelChanged) {
      return '';
    }

    return html`
      <div class="model-selector">
        <select 
          class="model-select"
          .value=${this.#selectedModel}
          ?disabled=${this.#isModelSelectorDisabled} 
          @change=${this.#handleModelChange.bind(this)}
          @focus=${this.#handleModelSelectorFocus.bind(this)}
        >
          ${this.#modelOptions.map(option => html`
            <option value=${option.value} ?selected=${option.value === this.#selectedModel}>${option.label}</option>
          `)}
        </select>
      </div>
    `;
  }

  #handleModelChange(event: Event): void {
    if (this.#isModelSelectorDisabled) {
      console.log('Model selector is disabled, ignoring change');
      return;
    }
    const selectElement = event.target as HTMLSelectElement;
    const selectedValue = selectElement.value;
    if (this.#onModelChanged) {
      this.#onModelChanged(selectedValue);
    }
  }

  #handleModelSelectorFocus(): void {
    if (this.#onModelSelectorFocus) {
      this.#onModelSelectorFocus();
    }
  }

  // Add this new method for copying text to clipboard
  #copyToClipboard(text: string): void {
    // Copy to clipboard using the Clipboard API
    navigator.clipboard.writeText(text)
      .then(() => {
        // Show a brief visual feedback by temporarily changing the tooltip text
        const copyButtons = this.shadowRoot?.querySelectorAll('.message-action-button') || [];
        copyButtons.forEach(button => {
          const tooltip = button.querySelector('.action-tooltip');
          if (tooltip) {
            const originalText = tooltip.textContent;
            tooltip.textContent = 'Copied!';
            // Reset after short delay
            setTimeout(() => {
              tooltip.textContent = originalText;
            }, 2000);
          }
        });
      })
      .catch(err => {
        console.error('Failed to copy text: ', err);
      });
  }
}

declare global {
  interface HTMLElementTagNameMap {
    'devtools-chat-view': ChatView;
  }
}
